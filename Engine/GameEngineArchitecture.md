# 游戏引擎架构笔记

## 3.2.2 声明 定义 和 链接

### 3.2.2.1 Translation Units Revisited

a C or C++ program is comprised of *translation units.* The compiler translates one .cpp file at a time, and for each one it generates an output file called an object file (.o or .obj).

The compiler only operates on one translation unit at a time, so whenever it encounters a reference to an external global variable or function, it must “go on faith” and assume that the entity in question really exists, as shown in Figure 3.7. 

链接器的主要工作是解析外部引用，在这种能力下它只能产生两种错误：

1. 可能找不到外部引用的目标，在这种情况下
   链接器生成“未解析的符号”错误。
2. 链接器可能会发现多个具有相同功能的变量或函数
   名称，在这种情况下，它会生成“多重定义符号”错误。

### 3.2.2.2 **Declaration versus Definition**

在 C 和 C++ 语言中，必须声明和定义变量和函数在使用之前完成。 理解 C 和 C++ 中声明和定义之间的区别很重要。

* 声明是对数据对象或函数的描述。它提供了带有实体名称及数据类型或函数签名的编译器（即，返回类型和参数类型）。
* 另一方面，定义描述了内存中的一个独特区域该程序。 这个内存可能包含一个变量，一个 struct 或 class，或函数的机器代码。

*定义和声明的多重性*

C/C++程序可以拥有多个相同的声明但每个只能有一个定义

*在头文件和内联中定义*

在头文件中放置定义通常是危险的。 这样做的原因应该很明显：如果包含定义的头文件是#included进入多个 .cpp 文件，这是产生“多重定义符号”链接器错误的可靠方法。

### 3.2.2.3 链接

​	C 和 C++ 中的每个定义都有一个称为链接的属性。 定义外部链接对翻译单元可见并可被翻译单元引用除了它出现的那个。具有内部链接的定义可以只能在它出现的翻译单元内“看到”，因此不能被其他翻译单位引用。

## 3.2.3 C/C++内存分布

### 3.2.3.1 可执行文件

​	构建 C/C++ 程序时，链接器会创建一个可执行文件。 大多数类似 UNIX 的操作系统，包括许多游戏机，都采用流行的可执行文件格式称为可执行文件和链接格式 (ELF)。 可执行因此，这些系统上的文件具有 .elf 扩展名。 Windows 可执行格式类似于 ELF 格式Windows 下的可执行文件有 exe 扩展名。 不管它的格式是什么，可执行文件总是包含一个程序的部分图像，因为它在运行时将存在于内存中。 我说一个“部分”映像，因为程序通常在运行时分配内存
除了在其可执行映像中布置的内存之外。

映像通常包含至少四部分

1. 文本段 代码段 包含程序定义的可执行机器代码
2. 数据段 包含所有初始化的全局和静态变量，所需内存会被精确布局 
3. BBS段 包含所有未初始化的全局和静态变量，未初始化的变量默认定义为0 运行时bbs保留请求的字节数和在程序入口调用前用零填充
4. 只读数据段 常量全局数据

### 3.2.3.2 栈堆

当可执行程序加载到内存并运行时，操作系统会为栈堆保留一块内存区域 每当一个函数被调用，栈堆内存的一块连续区域被压入栈堆被称为 堆栈帧

1. 它储存调用函数的返回地址以便执行当被调用函数返回时继续调用
2. 所有相关的cup寄存器内容都保存在堆栈帧中，这允许新函数以任何合适的方式使用寄存器，而不用但系覆盖调用函数所需的数据
3.  栈帧也包含了所有由函数声明的本地变量，他们也被称为自动变量。这允许每个不同的函数调用维护每个本地变量的私有副本，即使函数递归调用自身。

![image-20210806150707648](F:\HY\note\ReadingNote\Engine\img\image-20210806150707648.png)

入栈和出栈操作通常是通过调整CPU中单个寄存器的值来实现的

```cpp
void c()
{
	U32 localC1;    
}

F32 b()
{
    F32 localB1;
    I32 localB2;
    
    c();//call  function c()
    return localB1;  
}

void a()
{
    U32 aLocalsA1[5];
    
    F32 localA2 = b(); // call function b()
}
```

​	当包含自动变量的函数返回时，其堆栈帧被放弃，函数中的所有自动变量应该被视为它们不再存在。被这些变量所占用的内存始终存在于废弃的栈帧当中，一旦被另一个函数调用，该内存很可能会被覆盖。

### 3.2.3.3 Dynamic Allocation Heap 动态分配堆

数据可作为全局或静态变量或局部变量存储。全局和静态可在执行镜像中分配内存，这两种存储是静态定义得意味着编译时已知内存大小和布局。然而内存的需要并不是完全已知的，这就需要动态分配额外内存。

为了允许动态分配，操作系统维护一个内存块，运行的程序可以通过调用 *malloc()* 分配该内存，然后通过调用 *free(）*返回池供其他程序使用。
