# 游戏引擎架构笔记

## 3.2.2 声明 定义 和 链接

### 3.2.2.1 Translation Units Revisited

a C or C++ program is comprised of *translation units.* The compiler translates one .cpp file at a time, and for each one it generates an output file called an object file (.o or .obj).

The compiler only operates on one translation unit at a time, so whenever it encounters a reference to an external global variable or function, it must “go on faith” and assume that the entity in question really exists, as shown in Figure 3.7. 

链接器的主要工作是解析外部引用，在这种能力下它只能产生两种错误：

1. 可能找不到外部引用的目标，在这种情况下
   链接器生成“未解析的符号”错误。
2. 链接器可能会发现多个具有相同功能的变量或函数
   名称，在这种情况下，它会生成“多重定义符号”错误。

### 3.2.2.2 **Declaration versus Definition**

在 C 和 C++ 语言中，必须声明和定义变量和函数在使用之前完成。 理解 C 和 C++ 中声明和定义之间的区别很重要。

* 声明是对数据对象或函数的描述。它提供了带有实体名称及数据类型或函数签名的编译器（即，返回类型和参数类型）。
* 另一方面，定义描述了内存中的一个独特区域该程序。 这个内存可能包含一个变量，一个 struct 或 class，或函数的机器代码。

*定义和声明的多重性*

C/C++程序可以拥有多个相同的声明但每个只能有一个定义

*在头文件和内联中定义*

在头文件中放置定义通常是危险的。 这样做的原因应该很明显：如果包含定义的头文件是#included进入多个 .cpp 文件，这是产生“多重定义符号”链接器错误的可靠方法。

### 3.2.2.3 链接

​	C 和 C++ 中的每个定义都有一个称为链接的属性。 定义外部链接对翻译单元可见并可被翻译单元引用除了它出现的那个。具有内部链接的定义可以只能在它出现的翻译单元内“看到”，因此不能被其他翻译单位引用。

## 3.2.3 C/C++内存分布

### 3.2.3.1 可执行文件

​	构建 C/C++ 程序时，链接器会创建一个可执行文件。 大多数类似 UNIX 的操作系统，包括许多游戏机，都采用流行的可执行文件格式称为可执行文件和链接格式 (ELF)。 可执行因此，这些系统上的文件具有 .elf 扩展名。 Windows 可执行格式类似于 ELF 格式Windows 下的可执行文件有 exe 扩展名。 不管它的格式是什么，可执行文件总是包含一个程序的部分图像，因为它在运行时将存在于内存中。 我说一个“部分”映像，因为程序通常在运行时分配内存
除了在其可执行映像中布置的内存之外。

映像通常包含至少四部分

1. 文本段 代码段 包含程序定义的可执行机器代码
2. 数据段 包含所有初始化的全局和静态变量，所需内存会被精确布局 
3. BBS段 包含所有未初始化的全局和静态变量，未初始化的变量默认定义为0 运行时bbs保留请求的字节数和在程序入口调用前用零填充
4. 只读数据段 常量全局数据

### 3.2.3.2 栈堆

当可执行程序加载到内存并运行时，操作系统会为栈堆保留一块内存区域 每当一个函数被调用，栈堆内存的一块连续区域被压入栈堆被称为 堆栈帧

1. 它储存调用函数的返回地址以便执行当被调用函数返回时继续调用
2. 所有相关的cup寄存器内容都保存在堆栈帧中，这允许新函数以任何合适的方式使用寄存器，而不用但系覆盖调用函数所需的数据
3.  栈帧也包含了所有由函数声明的本地变量，他们也被称为自动变量。这允许每个不同的函数调用维护每个本地变量的私有副本，即使函数递归调用自身。

![image-20210806150707648](F:\HY\note\ReadingNote\Engine\img\image-20210806150707648.png)

入栈和出栈操作通常是通过调整CPU中单个寄存器的值来实现的

```cpp
void c()
{
	U32 localC1;    
}

F32 b()
{
    F32 localB1;
    I32 localB2;
    
    c();//call  function c()
    return localB1;  
}

void a()
{
    U32 aLocalsA1[5];
    
    F32 localA2 = b(); // call function b()
}
```

​	当包含自动变量的函数返回时，其堆栈帧被放弃，函数中的所有自动变量应该被视为它们不再存在。被这些变量所占用的内存始终存在于废弃的栈帧当中，一旦被另一个函数调用，该内存很可能会被覆盖。

### 3.2.3.3 Dynamic Allocation Heap 动态分配堆

数据可作为全局或静态变量或局部变量存储。全局和静态可在执行镜像中分配内存，这两种存储是静态定义得意味着编译时已知内存大小和布局。然而内存的需要并不是完全已知的，这就需要动态分配额外内存。

为了允许动态分配，操作系统维护一个内存块，运行的程序可以通过调用 *malloc()* 分配该内存，然后通过调用 *free(）*返回池供其他程序使用。

在c++中全局的 *new* 和 *delete* 操作符通常在堆中分配和释放内存。某些类可能重载这些操作符以自定义的方式分配内存，即使是**全局的** *new* 和 *delete* 操作符，所以你不能简单的假定 *new* 操作符是一直从堆中分配内存。

## 3.2.4 成员变量

*class* 或 *struct* 的声明不分配内存。这仅仅是对数据布局的一个描述—— 一个饼干模具用来 戳出 *class* 或 *struct* 的实例。

### 3.2.4.1 类静态成员

根据上下文语境*static*关键词具有许多不同的含义。

+ 在文件范围内使用时，*static* 意味着 限制此变量或函数的可见性，只能在此 *.cpp* 文件中可视。
+ 在函数范围内使用时，意味着此变量是一个全局变量不是自动变量 但只在此函数中可见
+ 在类或结构声明时 意味着此变量不是常规成员变量，但它的行为类似于全局变量。

在类声明中使用*static* 时 并不控制变量的可见性。

静态变量将自动被包含在其被声明的类或结构的命名空间中，所以在类或结构外使用时必须使用类或结构的命名来消除歧义性 例如 Foo::sStaticVar 

和全局变量的外部声明类似，类静态变量的声明不分配内存 内存必须在cpp文件中分配

## 3.2.5 内存中的对象布局

能可视化你类内存的分布是很有用的，通常很简明的 画一个盒子 数据成员被水平线分割



![image-20210809135917267](F:\HY\note\ReadingNote\Engine\GameEngineArchitecture.assets\image-20210809135917267.png)

数据成员的大小很重要，应该在图表中表示。这很容易使用每个数据成员的宽度来表示bits—i.e.的大小，32位整数应该大约是8位整数宽度的4倍

### 3.2.5.2 C++类内存布局

在内存布局方面，有两件事使得C++和C结构体略有不同，即继承与虚函数

当类B从类A继承时，类B的数据成员只是立即出现在类A的内存后面多重继承会做一些古怪的事情，比如在派生类的内存布局中包含单个基类的多个副本。我们不会在这里介绍细节，因为游戏程序员通常更喜欢完全避免多重继承。

如果一个类包含或继承一个或多个虚拟函数，则再添加四个字节这四个字节统称为虚拟表指针或v指针，因为它们包含一个指向数据结构的指针。每个具体类都有自己的虚表，并且该类的每个实例都有一个指向它的指针，存储在它的虚拟指针中。

## 3.3 捕获和处理错误

游戏引擎中有许多方式去捕获和处理错误情况。理解他们的不同机制和优缺点和何时使用，是个很重要的课题。

### 3.3.1  错误类型

一般有两种错误类型。

+ 用户操作错误
+ 程序错误--BUG

### 3.3.2 错误处理

在处理错误时，需求在两种类型之间存在显著差异。最好尽可能优雅地处理用户错误，向用户显示一些有用的信息，然后允许他或她继续工作——或者在游戏的情况下，继续玩游戏。

另一方面，程序员的错误不应该用优雅的“通知和继续”策略来处理。相反，通常最好停止程序并提供详细的低级调试信息，以便程序员可以快速识别和识别问题。
